<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Color Dino Game</title>
  <style>
    body {
      margin: 0;
      background: #202735;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
      user-select: none;
    }
    #gameContainer {
      text-align: center;
    }
    canvas {
      background: linear-gradient(#77c5ff, #e6f4ff);
      border: 3px solid #ffffff44;
      border-radius: 10px;
      box-shadow: 0 10px 30px #00000055;
      display: block;
      margin: 0 auto 10px;
    }
    #info {
      font-size: 14px;
      opacity: 0.9;
    }
    #info span {
      font-weight: 600;
      color: #ffdd66;
    }
  </style>
</head>
<body>
<div id="gameContainer">
  <canvas id="game" width="800" height="300"></canvas>
  <div id="info">
    <div><span>SPACE / ↑ / CLICK</span> to jump • <span>R</span> to restart</div>
    <div>Colorful Dino clone inspired by the Chrome game</div>
  </div>
</div>

<script>
  (function () {
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const width = canvas.width;
    const height = canvas.height;

    // Ground line
    const groundY = height - 50;

    // Game state
    let gameSpeed = 6;
    let gravity = 0.7;
    let isGameOver = false;
    let started = false;
    let score = 0;
    let highScore = 0;
    let spawnTimer = 0;
    let spawnInterval = 90; // frames

    // Dino properties
    const dino = {
      x: 80,
      y: groundY - 60,
      width: 60,
      height: 60,
      vy: 0,
      isJumping: false
    };

    const obstacles = [];

    // Utility: random integer
    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // Draw colorful, slightly detailed dinosaur
    function drawDino() {
      const x = dino.x;
      const y = dino.y;
      const w = dino.width;
      const h = dino.height;

      ctx.save();

      // Body
      ctx.fillStyle = "#6c5ce7"; // purple
      ctx.fillRect(x + w * 0.15, y + h * 0.25, w * 0.55, h * 0.55);

      // Belly
      ctx.fillStyle = "#a29bfe";
      ctx.fillRect(x + w * 0.2, y + h * 0.35, w * 0.25, h * 0.35);

      // Tail
      ctx.fillStyle = "#6c5ce7";
      ctx.beginPath();
      ctx.moveTo(x + w * 0.7, y + h * 0.45);
      ctx.lineTo(x + w * 1.0, y + h * 0.35);
      ctx.lineTo(x + w * 0.7, y + h * 0.65);
      ctx.closePath();
      ctx.fill();

      // Back plates (colorful spikes)
      const plateColors = ["#ff7675", "#fdcb6e", "#55efc4", "#74b9ff"];
      for (let i = 0; i < 4; i++) {
        ctx.fillStyle = plateColors[i];
        const px = x + w * (0.2 + i * 0.12);
        const py = y + h * 0.25;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + w * 0.08, py - h * 0.2);
        ctx.lineTo(px + w * 0.16, py);
        ctx.closePath();
        ctx.fill();
      }

      // Head
      ctx.fillStyle = "#6c5ce7";
      ctx.fillRect(x, y, w * 0.4, h * 0.35);

      // Eye
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(x + w * 0.3, y + h * 0.1, w * 0.05, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2d3436";
      ctx.beginPath();
      ctx.arc(x + w * 0.31, y + h * 0.1, w * 0.025, 0, Math.PI * 2);
      ctx.fill();

      // Mouth
      ctx.strokeStyle = "#2d3436";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.05, y + h * 0.25);
      ctx.lineTo(x + w * 0.3, y + h * 0.25);
      ctx.stroke();

      // Legs
      ctx.fillStyle = "#6c5ce7";
      const legWidth = w * 0.12;
      const legHeight = h * 0.3;
      ctx.fillRect(x + w * 0.2, y + h * 0.8 - legHeight, legWidth, legHeight);
      ctx.fillRect(x + w * 0.4, y + h * 0.8 - legHeight, legWidth, legHeight);

      ctx.restore();
    }

    // Obstacle (cactus-like but colorful)
    function createObstacle() {
      const heightOptions = [40, 55, 70];
      const h = heightOptions[randInt(0, heightOptions.length - 1)];
      const w = randInt(20, 35);

      obstacles.push({
        x: width + 20,
        y: groundY - h,
        width: w,
        height: h,
        color: ["#e17055", "#00cec9", "#fd79a8"][randInt(0, 2)]
      });
    }

    function drawObstacle(ob) {
      ctx.save();
      ctx.fillStyle = ob.color;

      // Main stem
      ctx.fillRect(ob.x, ob.y, ob.width, ob.height);

      // Side arms
      const armHeight = ob.height * 0.4;
      const armWidth = ob.width * 0.6;

      ctx.fillRect(
        ob.x - armWidth,
        ob.y + ob.height * 0.2,
        armWidth,
        armHeight
      );
      ctx.fillRect(
        ob.x + ob.width,
        ob.y + ob.height * 0.35,
        armWidth,
        armHeight
      );

      ctx.restore();
    }

    // Ground and background
    function drawGround() {
      ctx.strokeStyle = "#2d3436";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(width, groundY);
      ctx.stroke();

      // Small decorative ground dots
      ctx.fillStyle = "#b2bec3";
      for (let i = 0; i < 18; i++) {
        const gx = (i * 50 + (score % 50)) % width;
        const gy = groundY + randInt(5, 12);
        ctx.fillRect(gx, gy, 4, 3);
      }
    }

    function drawBackground() {
      // Sun
      ctx.save();
      ctx.fillStyle = "#ffeaa7";
      ctx.beginPath();
      ctx.arc(70, 60, 30, 0, Math.PI * 2);
      ctx.fill();

      // Clouds
      function drawCloud(cx, cy, scale) {
        ctx.fillStyle = "#ffffffcc";
        ctx.beginPath();
        ctx.arc(cx, cy, 12 * scale, 0, Math.PI * 2);
        ctx.arc(cx + 15 * scale, cy + 5 * scale, 10 * scale, 0, Math.PI * 2);
        ctx.arc(cx - 15 * scale, cy + 5 * scale, 10 * scale, 0, Math.PI * 2);
        ctx.fill();
      }

      const t = (Date.now() / 40) % (width + 200);
      drawCloud(width - (t % (width + 100)), 70, 1.2);
      drawCloud(width - ((t + 200) % (width + 100)), 40, 0.9);
      drawCloud(width - ((t + 400) % (width + 100)), 100, 1.1);

      ctx.restore();
    }

    // Collision detection (AABB)
    function isColliding(a, b) {
      return !(
        a.x + a.width < b.x ||
        a.x > b.x + b.width ||
        a.y + a.height < b.y ||
        a.y > b.y + b.height
      );
    }

    // Reset game
    function resetGame() {
      obstacles.length = 0;
      score = 0;
      gameSpeed = 6;
      spawnTimer = 0;
      isGameOver = false;
      dino.y = groundY - dino.height;
      dino.vy = 0;
      dino.isJumping = false;
      started = false;
    }

    // Jump
    function jump() {
      if (isGameOver) return;
      if (!started) started = true;
      if (!dino.isJumping) {
        dino.vy = -13;
        dino.isJumping = true;
      }
    }

    // Input handlers
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "ArrowUp") {
        e.preventDefault();
        jump();
      }
      if (e.code === "KeyR") {
        resetGame();
      }
    });

    canvas.addEventListener("mousedown", () => {
      jump();
    });

    // Main loop
    function update() {
      ctx.clearRect(0, 0, width, height);

      drawBackground();
      drawGround();

      // Game not started yet: show instructions
      if (!started && !isGameOver) {
        ctx.fillStyle = "#2d3436";
        ctx.font = "20px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Press SPACE / ↑ / CLICK to start", width / 2, height / 2 - 10);
      }

      // Dino physics
      dino.vy += gravity;
      dino.y += dino.vy;

      if (dino.y + dino.height >= groundY) {
        dino.y = groundY - dino.height;
        dino.vy = 0;
        dino.isJumping = false;
      }

      drawDino();

      // Obstacles + scoring only when game started and not over
      if (started && !isGameOver) {
        spawnTimer++;
        if (spawnTimer >= spawnInterval) {
          createObstacle();
          spawnTimer = 0;
          // Slightly speed up game and increase difficulty over time
          if (spawnInterval > 55) spawnInterval -= 1;
          gameSpeed += 0.02;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          const ob = obstacles[i];
          ob.x -= gameSpeed;
          drawObstacle(ob);

          if (ob.x + ob.width < 0) {
            obstacles.splice(i, 1);
            score += 1;
            if (score > highScore) highScore = score;
          } else if (isColliding(
            { x: dino.x + 10, y: dino.y + 10, width: dino.width - 20, height: dino.height - 20 },
            ob
          )) {
            isGameOver = true;
          }
        }
      } else {
        // Still draw existing obstacles when game is over (no movement)
        for (const ob of obstacles) {
          drawObstacle(ob);
        }
      }

      // Score display
      ctx.fillStyle = "#2d3436";
      ctx.font = "18px system-ui";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 20, 30);
      ctx.textAlign = "right";
      ctx.fillText("High: " + highScore, width - 20, 30);

      // Game over text
      if (isGameOver) {
        ctx.fillStyle = "#d63031";
        ctx.font = "32px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", width / 2, height / 2 - 10);

        ctx.fillStyle = "#2d3436";
        ctx.font = "18px system-ui";
        ctx.fillText("Press R to restart", width / 2, height / 2 + 20);
      }

      requestAnimationFrame(update);
    }

    // Start loop
    resetGame();
    update();
  })();
</script>
</body>
</html>
